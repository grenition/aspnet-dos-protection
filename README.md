
# Тестирование

Для тестирования полученного Middleware, был создан тестовый стенд, который представляет собой два .NET проекта:
1. `TestEnvironment.Server.csproj`
   Это ASP.NET WebApi, которое использует `PowChallengeMiddleware` с проекта `DosProtection.AspNetLib.csproj` для автоматической выдачи PoW задач для каждого запроса к Api.
   API имеет всего один POST ендпоинт: `/test`, который в случае успеха возвращает приветственное сообщение.
2.  `TestEnvironment.Client.csproj`
    Это консольное приложение - стресс тест для API. В течении определенного времени оно шлет десятки тысяч запросов к серверу, параллельно решая PoW задачи. Таким образом мы имитируем DoS атаку.

### Тест кейс 1: Без решения челленджей, Без использования пула, 20 тысяч запросов в секунду

При таком конфиге, сервер упал в первые несколько секунд.
```json
"StressTestConfig":{  
  "Seconds": 1000,  
  "SolvePow": false,  
  "RequestsPerSecond": 100000,  
  "MaxParallelOperationsCount": 10000  
}
```

Причина была в том, что при каждом обращении к ручке, мы генерируем новую задачу, что весьма накладно по ресурсам на больших дистанциях. Решение нашлось в создании общего пула уже сгенерирванных, которые будут подменять друг друга при решении.

Был установлен такой конфиг - запоминаем 200 задач.
```json
"PowConfig":{
  "Difficulty": 16,
  "CacheLifetimeSeconds": 15,
  "PoolSize": 200
}
```

### Тест кейс 2: Без решения челленджей, С использованием пула, 20 тысяч запросов в секунду

```json
"StressTestConfig":{  
  "Seconds": 1000,  
  "SolvePow": false,  
  "RequestsPerSecond": 20000,  
  "MaxParallelOperationsCount": 10000  
}
```

![](docs/images/testcase_2.png)

### Тест кейс 3: Без решения челленджей, С использованием пула, 100 тысяч запросов в секунду

```json
"StressTestConfig":{  
  "Seconds": 1000,  
  "SolvePow": false,  
  "RequestsPerSecond": 100000,  
  "MaxParallelOperationsCount": 10000  
}
```
![](docs/images/testcase_3.png)

#### Тесты 2 и 3
Эти тесты показывают эффективность `ChallengePool`. Хранение заранее заготовленных задач лучше по производительности и стабильности, чем генерация челленджей при каждом обращении. 

Может показаться, что сильно растет потребление памяти. Но это быстро уходит после очередной сборки мусора.

### Тест кейс 4: С решением челленджей, < 100 запросов в секунду

В данном кейсе был включен просчет задач на хеширование со стороны клиента, из-за чего он стал не способен физически отправлять больше 100 запросов в секунду, так как ему требовалось время на выполнение задач. Потребление CPU на сервере значительно снизилось.

```json
"StressTestConfig":{
"Seconds": 1000,
  "SolvePow": true,
  "RequestsPerSecond": 1000,
  "MaxParallelOperationsCount": 10000
}
```

![](docs/images/testcase_4.png)

### Итоги по тестам

Защита работает, она дает возможность почти полностью предотвратить DoS атаки на **внутреннюю** инфраструктуру системы. Но есть и уязвимые места, например, точка входа, получение задания. Здесь идеально будет скомбинировать лучшее от всех подходов. Использовать rate limiting, proxy для контроля входящего трафика. 